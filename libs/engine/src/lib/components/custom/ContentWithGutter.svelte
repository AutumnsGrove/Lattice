<script lang="ts">
	import { untrack, mount, unmount } from "svelte";
	import { browser } from "$app/environment";
	import TableOfContents from "./TableOfContents.svelte";
	import MobileTOC from "./MobileTOC.svelte";
	import GutterItem from "./GutterItem.svelte";
	import {
		getAnchorKey,
		getUniqueAnchors,
		getItemsForAnchor,
		getOrphanItems,
		findAnchorElement,
		type GutterItem as GutterItemType,
		type Header,
	} from "$lib/utils/gutter";
	import type { HumProvider } from "$lib/ui/components/content/hum/types";
	import "$lib/styles/content.css";

	let {
		content = "",
		gutterContent = [] as GutterItemType[],
		headers = [] as Header[],
		showTableOfContents = true,
		children,
	} = $props();

	// References to inline gutter containers for each anchor
	let mobileGutterRefs = $state<Record<string, HTMLElement>>({});

	// Reference to the content body for DOM insertion
	let contentBodyElement = $state<HTMLElement | undefined>();

	// Compute unique anchors once as a derived value (performance optimization)
	let uniqueAnchors = $derived(getUniqueAnchors(gutterContent));
	let orphanItems = $derived(getOrphanItems(gutterContent, headers));

	// Check if we have content for gutters
	let hasLeftGutter = $derived(gutterContent && gutterContent.length > 0);
	let hasRightGutter = $derived(showTableOfContents && headers && headers.length > 0);

	/**
	 * Helper to get anchor key with headers context
	 */
	function getKey(anchor: string) {
		return getAnchorKey(anchor, headers);
	}

	/**
	 * Get items for a specific anchor
	 */
	function getItems(anchor: string) {
		return getItemsForAnchor(gutterContent, anchor);
	}

	/**
	 * Generate unique key for a gutter item
	 */
	function getItemKey(item: GutterItemType, index: number): string {
		const parts = [
			item.type || "unknown",
			item.file || item.src || item.url || "",
			item.anchor || "",
			index.toString(),
		];
		return parts.join("-");
	}

	// Below this count, embeds hydrate immediately (no IntersectionObserver overhead).
	// Above it, lazy hydration via observer kicks in to avoid mounting dozens of
	// components simultaneously on long posts.
	const IMMEDIATE_HYDRATION_LIMIT = 3;

	// Allowlist of valid curio names — prevents arbitrary component loading
	const VALID_CURIOS = new Set([
		"guestbook",
		"hitcounter",
		"poll",
		"nowplaying",
		"moodring",
		"badges",
		"blogroll",
		"webring",
		"shelves",
		"activitystatus",
		"statusbadges",
		"artifacts",
	]);

	/**
	 * Shared click handler for code copy buttons generated by the markdown-it
	 * code renderer (see markdown.ts). Uses event delegation — one listener on
	 * the .content-body container instead of one per code block. The
	 * `.code-block-copy[data-code]` selector is coupled to the markup structure
	 * emitted by the fence/code_block renderer rules in markdown.ts.
	 */
	function handleCopyClick(event: Event) {
		const target = event.target as HTMLElement;
		const button = target.closest(".code-block-copy") as HTMLElement | null;
		if (!button) return;

		const codeText = button.getAttribute("data-code");
		if (!codeText) return;

		// Decode HTML entities back to original text
		const textarea = document.createElement("textarea");
		textarea.innerHTML = codeText;
		const decodedText = textarea.value;

		navigator.clipboard
			.writeText(decodedText)
			.then(() => {
				const copyText = button.querySelector(".copy-text");
				const originalText = copyText?.textContent || "Copy";
				if (copyText) copyText.textContent = "Copied!";
				button.classList.add("copied");

				setTimeout(() => {
					if (copyText) copyText.textContent = originalText;
					button.classList.remove("copied");
				}, 2000);
			})
			.catch((err) => {
				console.error("Failed to copy code:", err);
				const copyText = button.querySelector(".copy-text");
				if (copyText) copyText.textContent = "Failed";
				setTimeout(() => {
					if (copyText) copyText.textContent = "Copy";
				}, 2000);
			});
	}

	/**
	 * Mount a single Hum card embed.
	 * Returns a cleanup function to unmount the component.
	 *
	 * Uses a cancellation flag so that if the effect tears down while
	 * the dynamic import is still in-flight, the resolved module won't
	 * mount against a potentially detached DOM node.
	 */
	function mountHumCard(card: Element): (() => void) | null {
		const url = card.getAttribute("data-hum-url");
		const provider = (card.getAttribute("data-hum-provider") || "unknown") as HumProvider;
		if (!url || card.hasAttribute("data-hum-mounted")) return null;

		card.setAttribute("data-hum-mounted", "true");
		let cancelled = false;
		let cleanup: (() => void) | null = null;

		import("$lib/ui/components/content/hum/HumCard.svelte")
			.then((module) => {
				if (cancelled) return;
				card.innerHTML = "";
				const component = mount(module.default, {
					target: card as HTMLElement,
					props: { url, provider },
				});
				cleanup = () => unmount(component);
			})
			.catch((err) => {
				console.warn("[Hum] Failed to mount card:", err);
			});

		return () => {
			cancelled = true;
			cleanup?.();
		};
	}

	/**
	 * Mount a single Curio embed.
	 * Returns a cleanup function to unmount the component.
	 *
	 * Uses a cancellation flag so that if the effect tears down while
	 * the dynamic import is still in-flight, the resolved module won't
	 * mount against a potentially detached DOM node.
	 */
	function mountCurio(el: Element): (() => void) | null {
		const curioName = el.getAttribute("data-grove-curio");
		const curioArg = el.getAttribute("data-curio-arg") || "";
		if (!curioName || el.hasAttribute("data-curio-mounted")) return null;

		if (!VALID_CURIOS.has(curioName)) {
			console.warn(`[Curio] Unknown curio: ${curioName}`);
			return null;
		}

		el.setAttribute("data-curio-mounted", "true");
		const componentName = curioName.charAt(0).toUpperCase() + curioName.slice(1);
		let cancelled = false;
		let cleanup: (() => void) | null = null;

		import(`$lib/ui/components/content/curios/Curio${componentName}.svelte`)
			.then((module) => {
				if (cancelled) return;
				el.innerHTML = "";
				const component = mount(module.default, {
					target: el as HTMLElement,
					props: { arg: curioArg },
				});
				cleanup = () => unmount(component);
			})
			.catch((err) => {
				if (cancelled) return;
				console.warn(`[Curio] Failed to mount ${curioName}:`, err);
				el.innerHTML = '<span class="grove-curio-error">Curio unavailable</span>';
			});

		return () => {
			cancelled = true;
			cleanup?.();
		};
	}

	/**
	 * Lazy hydration: Use IntersectionObserver to hydrate Hum cards and Curios
	 * only when they scroll near the viewport. This prevents mounting dozens
	 * of embeds simultaneously on long posts, which was causing browser lockup.
	 */
	$effect(() => {
		if (!browser) return;

		const contentEl = contentBodyElement;
		if (!contentEl) return;

		// Collect all hydratable elements in a single DOM query
		const hydratables = contentEl.querySelectorAll(
			".hum-card[data-hum-url]:not([data-hum-mounted]), .grove-curio[data-grove-curio]:not([data-curio-mounted])",
		);
		if (hydratables.length === 0) return;

		const cleanups: Array<() => void> = [];

		// For short content (few embeds), hydrate immediately — no need for observer overhead
		if (hydratables.length <= IMMEDIATE_HYDRATION_LIMIT) {
			hydratables.forEach((el) => {
				let cleanup: (() => void) | null;
				if (el.classList.contains("hum-card")) {
					cleanup = mountHumCard(el);
				} else {
					cleanup = mountCurio(el);
				}
				if (cleanup) cleanups.push(cleanup);
			});

			return () => cleanups.forEach((fn) => fn());
		}

		// For long content with many embeds, use IntersectionObserver for lazy hydration
		const observer = new IntersectionObserver(
			(entries) => {
				for (const entry of entries) {
					if (!entry.isIntersecting) continue;

					const el = entry.target;
					observer.unobserve(el);

					let cleanup: (() => void) | null;
					if (el.classList.contains("hum-card")) {
						cleanup = mountHumCard(el);
					} else {
						cleanup = mountCurio(el);
					}
					if (cleanup) cleanups.push(cleanup);
				}
			},
			{
				// Start hydrating when element is within 300px of viewport
				rootMargin: "300px",
			},
		);

		hydratables.forEach((el) => observer.observe(el));

		return () => {
			observer.disconnect();
			cleanups.forEach((fn) => fn());
		};
	});

	// Add IDs to headers and position inline gutter items via DOM insertion
	$effect(() => {
		// Track contentBodyElement outside untrack() so effect re-runs when element becomes available
		const contentEl = contentBodyElement;
		if (!contentEl) return;

		// Track dependencies that should trigger re-positioning of inline gutter items.
		// These are read here (outside untrack) so changes cause the effect to re-run,
		// but the actual DOM manipulation happens inside untrack() to avoid loops.

		uniqueAnchors;

		headers;

		content;

		// Track moved elements for cleanup
		const movedElements: Array<{
			element: HTMLElement;
			originalParent: HTMLElement | null;
			originalNextSibling: Node | null;
		}> = [];

		untrack(() => {
			// First, add IDs to headers
			if (headers && headers.length > 0) {
				const headerElements = (contentEl as HTMLElement).querySelectorAll(
					"h1, h2, h3, h4, h5, h6",
				);
				headerElements.forEach((el: Element) => {
					const text = (el as HTMLElement).textContent?.trim() || "";
					const matchingHeader = headers.find((h: Header) => h.text === text);
					if (matchingHeader) {
						(el as HTMLElement).id = matchingHeader.id;
					}
				});
			}

			// Position inline gutter items for all anchor types
			for (const anchor of uniqueAnchors) {
				const anchorKey = getKey(anchor);
				const mobileGutterEl = mobileGutterRefs[anchorKey];
				if (!mobileGutterEl || mobileGutterEl.children.length === 0) continue;

				// Track original parent for cleanup
				const originalParent = mobileGutterEl.parentElement;
				const originalNextSibling = mobileGutterEl.nextSibling;

				const targetEl = findAnchorElement(anchor, contentEl as HTMLElement, headers);

				if (targetEl) {
					targetEl.insertAdjacentElement("afterend", mobileGutterEl);
					movedElements.push({ element: mobileGutterEl, originalParent, originalNextSibling });
				} else {
					// Fallback: anchor not found - log warning and position after first heading or at end
					if (import.meta.env.DEV) {
						const availableAnchors = Array.from(contentEl.querySelectorAll("[id]")).map(
							(el) => el.id,
						);
						console.warn(`[ContentWithGutter] Inline gutter anchor not found: ${anchor}`, {
							anchorKey,
							availableAnchors: availableAnchors.length > 0 ? availableAnchors : "none",
						});
					}

					// Fallback positioning: after first heading or at end of content
					const fallbackAnchor =
						contentEl.querySelector("h1, h2, h3, h4, h5, h6") || contentEl.lastElementChild;
					if (fallbackAnchor && fallbackAnchor instanceof HTMLElement) {
						fallbackAnchor.insertAdjacentElement("afterend", mobileGutterEl);
						movedElements.push({ element: mobileGutterEl, originalParent, originalNextSibling });
					}
				}
			}
		});

		// Cleanup: restore moved elements to their original positions
		return () => {
			for (const { element, originalParent, originalNextSibling } of movedElements) {
				if (originalParent && element.parentElement !== originalParent) {
					if (originalNextSibling) {
						originalParent.insertBefore(element, originalNextSibling);
					} else {
						originalParent.appendChild(element);
					}
				}
			}
		};
	});
</script>

<div
	class="content-layout"
	class:has-gutters={hasRightGutter}
	class:has-right-gutter={hasRightGutter}
>
	<!-- Main Content -->
	<article class="content-article">
		<!-- Custom header content via children/slot -->
		{#if children}
			{@render children()}
		{/if}

		<!-- Orphan items at top (no matching anchor) -->
		{#if hasLeftGutter && orphanItems.length > 0}
			<div class="mobile-gutter-content">
				{#each orphanItems as item, index (getItemKey(item, index))}
					<GutterItem {item} />
				{/each}
			</div>
		{/if}

		<!-- Inline gutter containers for each anchor (will be moved into position via DOM insertion) -->
		{#if hasLeftGutter}
			{#each uniqueAnchors as anchor (anchor)}
				{@const anchorKey = getKey(anchor)}
				{@const anchorItems = getItems(anchor)}
				{#if anchorItems.length > 0}
					<div
						class="mobile-gutter-content mobile-gutter-inline"
						bind:this={mobileGutterRefs[anchorKey]}
					>
						{#each anchorItems as item, index (getItemKey(item, index))}
							<GutterItem {item} />
						{/each}
					</div>
				{/if}
			{/each}
		{/if}

		<!-- svelte-ignore a11y_click_events_have_key_events -->
		<!-- svelte-ignore a11y_no_static_element_interactions -->
		<!-- svelte-ignore a11y_no_noninteractive_element_interactions -->
		<div
			class="prose prose-lg dark:prose-invert max-w-none content-body"
			bind:this={contentBodyElement}
			onclick={handleCopyClick}
		>
			<!-- Content is sanitized server-side (sanitize-html). No client-side re-sanitization needed. -->
			<!-- eslint-disable-next-line svelte/no-at-html-tags -- server-sanitized HTML content -->
			{@html content}
		</div>
	</article>

	<!-- Right Gutter - Table of Contents -->
	{#if hasRightGutter}
		<div class="right-gutter-container desktop-only">
			<TableOfContents {headers} />
		</div>
	{/if}
</div>

<!-- Mobile TOC Button -->
{#if hasRightGutter}
	<MobileTOC {headers} />
{/if}
