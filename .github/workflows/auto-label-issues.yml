name: Auto-Label Issues

on:
  issues:
    types: [opened, edited]

jobs:
  label:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Label by Grove component
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();

            // --- Component Labels ---
            // Two strategies based on name uniqueness:
            //
            // UNIQUE names (heartwood, lattice, foliage, mycelium, lumen, patina,
            //   curio, arbor, petal): Safe to match anywhere (title or body) since
            //   these words don't appear in normal English.
            //
            // AMBIGUOUS names (clearing, shade, plant, amber, vine, ivy, meadow,
            //   forests, graft): Only match the bare product name in the TITLE.
            //   In the body, require specific compound phrases that clearly refer
            //   to the Grove product, not the common English word.

            // Unique product names — safe to match anywhere
            const uniqueComponents = [
              { label: 'heartwood', proper: /\bheartwood\b/, titleFallback: /\b(oauth|passkey|session.?do|pkce)\b/ },
              { label: 'lattice',   proper: /\blattice\b/,   titleFallback: /\b(groveengine|monorepo|multi.?tenant)\b/ },
              { label: 'foliage',   proper: /\bfoliage\b/,   titleFallback: /\b(theme engine|design tokens|per.tenant theming)\b/ },
              { label: 'mycelium',  proper: /\bmycelium\b/,  titleFallback: /\b(mcp server|mcp tool|model context protocol)\b/ },
              { label: 'lumen',     proper: /\blumen\b/,     titleFallback: /\b(ai gateway|llm routing|ai pipeline)\b/ },
              { label: 'patina',    proper: /\bpatina\b/,    titleFallback: /\b(automated backup|cold storage backup)\b/ },
              { label: 'curio',     proper: /\bcurios?\b/,   titleFallback: /\b(museum exhibit|cabinet of wonders|guestbook)\b/ },
              { label: 'arbor',     proper: /\barbor\b/,     titleFallback: /\b(admin panel|admin dashboard|admin interface)\b/ },
              { label: 'petal',     proper: /\bpetal\b/,     titleFallback: /\b(content moderation|csam|photodna|image moderation)\b/ },
              { label: 'landing',   proper: /\blanding site\b/, titleFallback: /\b(grove\.place marketing|knowledge base|forest page)\b/ },
            ];

            // --- Pattern Labels ---
            // Patterns are reusable architectural solutions. Match pattern names
            // anywhere (title or body) since they're unique Grove terminology.
            // Note: Uses github-script JavaScript API (safe), not shell interpolation.
            const patterns = [
              { label: 'pattern:firefly',   pattern: /\bfirefly\b/,   fallback: /\b(ephemeral server|ignite.*fade|on.demand.*server)\b/ },
              { label: 'pattern:loom',      pattern: /\bloom\b/,      fallback: /\b(durable object|session.?do|tenant.?do|post.?do)\b/ },
              { label: 'pattern:prism',     pattern: /\bprism\b/,     fallback: /\b(glassmorphism|seasonal theme|design system layer)\b/ },
              { label: 'pattern:sentinel',  pattern: /\bsentinel\b/,  fallback: /\b(load test|scale validation|ramp.up test)\b/ },
              { label: 'pattern:songbird',  pattern: /\bsongbird\b/,  fallback: /\b(prompt injection|canary.*kestrel|three.layer defense)\b/ },
              { label: 'pattern:threshold', pattern: /\bthreshold\b/, fallback: /\b(rate limit|abuse prevention|graduated response)\b/ },
            ];

            // Ambiguous product names — bare name only in title, specific phrases in body
            const ambiguousComponents = [
              {
                label: 'shade',
                titleMatch: /\bshade\b/,
                bodyMatch: /\b(shade layer|shade protection|shade defense|ai crawler|scraper protection|content protection|data harvesting|bot defense|seven.layer defense)\b/,
                titleFallback: /\b(ai crawler protection|scraper defense|content harvesting)\b/
              },
              {
                label: 'clearing',
                titleMatch: /\bclearing\b(?!\s+(up|out|away|the|things?))/,
                bodyMatch: /\b(clearing.monitor|clearing.phase|status page|uptime monitor|health.check endpoint|incident management|platform health)\b/,
                titleFallback: /\b(status page|uptime monitor|platform health)\b/
              },
              {
                label: 'plant',
                titleMatch: /\bplant\b(?!\s+(a|the|some|more|trees?|based))/,
                bodyMatch: /\b(plant onboarding|plant signup|plant deployment|signup flow|onboarding flow|lemonsqueezy|lemon.?squeezy|store verification|tenant onboarding)\b/,
                titleFallback: /\b(signup flow|onboarding flow|tenant onboarding|lemonsqueezy)\b/
              },
              {
                label: 'amber',
                titleMatch: /\bamber\b/,
                bodyMatch: /\b(amber storage|amber cdn|amber zip|r2 storage|image storage|cdn storage|jxl|jpeg.?xl|image.?pipeline)\b/,
                titleFallback: /\b(r2 storage|cdn storage|image pipeline|jxl|jpeg.?xl)\b/
              },
              {
                label: 'ivy',
                titleMatch: /\bivy\b/,
                bodyMatch: /\b(ivy mail|ivy email|grove\.place email|email client|resend broadcast|email notification|privacy.first email)\b/,
                titleFallback: /\b(email client|email notification|resend broadcast)\b/
              },
              {
                label: 'meadow',
                titleMatch: /\bmeadow\b/,
                bodyMatch: /\b(meadow social|meadow feed|social feed|community feed|opt.in community)\b/,
                titleFallback: /\b(social feed|community feed)\b/
              },
              {
                label: 'forests',
                titleMatch: /\bforests?\b(?!\s+page)/,
                bodyMatch: /\b(forest page|community grove|themed communit|the prism|the terminal)\b/,
                titleFallback: /\b(forest page|community grove)\b/
              },
              {
                label: 'vine',
                titleMatch: /\bvines?\b/,
                bodyMatch: /\b(vine connection|margin note|gutter content|curator.s? note|content relationship)\b/,
                titleFallback: /\b(margin note|curator.s? note|content relationship)\b/
              },
              {
                label: 'graft',
                titleMatch: /\bgrafts?\b/,
                bodyMatch: /\b(feature flag|graft control|per.tenant feature|grafts? admin|graft.* ui)\b/,
                titleFallback: /\b(feature flag|per.tenant feature)\b/
              },
            ];

            // --- Type Labels (pick ONE, highest specificity wins) ---
            // Only matches against the title to avoid false positives from body text.
            const typesByPriority = [
              { label: 'security',      pattern: /\b(security|vulnerabilit|xss|csrf)\b/ },
              { label: 'bug',           pattern: /\[bug\]|\bbug\b/ },
              { label: 'feature',       pattern: /\[feat(ure)?\]|\bimplement\b/ },
              { label: 'enhancement',   pattern: /\b(enhance|improve|optimize|refactor)\b/ },
              { label: 'documentation', pattern: /\b(docs?|documentation|guide)\b/ },
            ];

            // --- Priority Labels (pick ONE, highest wins) ---
            // Only matches against the title.
            const prioritiesByRank = [
              { label: 'priority-critical', pattern: /\b(critical|urgent|blocker)\b/ },
              { label: 'priority-high',     pattern: /\b(high.?priority|important)\b/ },
              { label: 'priority-low',      pattern: /\b(low.?priority|nice.to.have|eventually|post.launch)\b/ },
            ];

            const labelsToAdd = new Set();

            // Check unique components: proper nouns safe to match in title+body
            for (const { label, proper, titleFallback } of uniqueComponents) {
              if (proper.test(title) || proper.test(body)) {
                labelsToAdd.add(label);
              } else if (titleFallback.test(title)) {
                labelsToAdd.add(label);
              }
            }

            // Check patterns: match pattern name or fallback phrases anywhere
            for (const { label, pattern, fallback } of patterns) {
              if (pattern.test(title) || pattern.test(body)) {
                labelsToAdd.add(label);
              } else if (fallback.test(title) || fallback.test(body)) {
                labelsToAdd.add(label);
              }
            }

            // Check ambiguous components: bare name title-only, compound phrases in body
            for (const { label, titleMatch, bodyMatch, titleFallback } of ambiguousComponents) {
              if (titleMatch.test(title)) {
                labelsToAdd.add(label);
              } else if (bodyMatch.test(body)) {
                labelsToAdd.add(label);
              } else if (titleFallback.test(title)) {
                labelsToAdd.add(label);
              }
            }

            // Cap component labels at 3 max
            const componentLabels = [...labelsToAdd];
            if (componentLabels.length > 3) {
              // Keep only title-matched components
              labelsToAdd.clear();
              for (const { label, proper, titleFallback } of uniqueComponents) {
                if (proper.test(title) || titleFallback.test(title)) {
                  labelsToAdd.add(label);
                }
              }
              for (const { label, titleMatch, titleFallback } of ambiguousComponents) {
                if (titleMatch.test(title) || titleFallback.test(title)) {
                  labelsToAdd.add(label);
                }
              }
            }

            // Check types: pick the first (highest priority) match in title only
            for (const { label, pattern } of typesByPriority) {
              if (pattern.test(title)) {
                labelsToAdd.add(label);
                break; // Only one type label
              }
            }

            // Check priorities: pick the first (highest rank) match in title only
            for (const { label, pattern } of prioritiesByRank) {
              if (pattern.test(title)) {
                labelsToAdd.add(label);
                break; // Only one priority label
              }
            }

            // Add labels if any were found
            const labels = [...labelsToAdd];
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels
              });

              console.log(`Added ${labels.length} labels: ${labels.join(', ')}`);
            } else {
              console.log('No labels matched for this issue.');
            }
