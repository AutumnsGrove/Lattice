name: Auto-tag on Version Bump

on:
  push:
    branches:
      - main
    paths:
      - "libs/engine/package.json"
  workflow_dispatch:
    inputs:
      force_snapshot:
        description: "Force snapshot generation even without version change"
        required: false
        default: "false"
        type: boolean
      backfill_summaries:
        description: "Backfill AI summaries for all historical versions"
        required: false
        default: "false"
        type: boolean

permissions:
  contents: write
  packages: write

jobs:
  tag-and-snapshot:
    if: github.event.inputs.backfill_summaries != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for accurate commit count

      - name: Check for version change
        id: version
        run: |
          # Get current version
          CURRENT=$(jq -r '.version' libs/engine/package.json)
          echo "current=$CURRENT" >> $GITHUB_OUTPUT

          # Get previous version
          git show HEAD~1:libs/engine/package.json > /tmp/prev-package.json 2>/dev/null || echo '{"version":"0.0.0"}' > /tmp/prev-package.json
          PREVIOUS=$(jq -r '.version' /tmp/prev-package.json)
          echo "previous=$PREVIOUS" >> $GITHUB_OUTPUT

          # Check if changed
          if [ "$CURRENT" != "$PREVIOUS" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Version changed: $PREVIOUS â†’ $CURRENT"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "Version unchanged: $CURRENT"
          fi

      - name: Check if tag exists
        id: tag_exists
        if: steps.version.outputs.changed == 'true'
        run: |
          TAG="v${{ steps.version.outputs.current }}"
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Tag $TAG already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Tag $TAG does not exist"
          fi

      - name: Create and push tag
        id: create_tag
        if: steps.version.outputs.changed == 'true' && steps.tag_exists.outputs.exists == 'false'
        run: |
          TAG="v${{ steps.version.outputs.current }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"
          echo "tag_name=$TAG" >> $GITHUB_OUTPUT
          echo "Created and pushed tag: $TAG"

      - name: Generate repository snapshot
        id: snapshot
        if: (steps.version.outputs.changed == 'true' && steps.tag_exists.outputs.exists == 'false') || github.event.inputs.force_snapshot == 'true'
        run: |
          TAG="${{ steps.create_tag.outputs.tag_name || format('v{0}', steps.version.outputs.current) }}"
          echo "Generating snapshot for: $TAG"

          chmod +x ./scripts/repo/repo-snapshot.sh
          ./scripts/repo/repo-snapshot.sh "$TAG"

          echo "tag_name=$TAG" >> $GITHUB_OUTPUT

      - name: Generate release summary
        id: summary
        if: steps.snapshot.outcome == 'success'
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          TAG="${{ steps.snapshot.outputs.tag_name }}"
          echo "Generating release summary for: $TAG"

          # Make script executable
          chmod +x ./scripts/generate/generate-release-summary.sh

          # Generate summary (will use previous tag automatically)
          ./scripts/generate/generate-release-summary.sh "$TAG" || echo "Warning: Summary generation failed, continuing..."

      - name: Setup pnpm
        if: steps.snapshot.outcome == 'success'
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        if: steps.snapshot.outcome == 'success'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"
          cache-dependency-path: "**/pnpm-lock.yaml"

      - name: Calculate package size
        if: steps.snapshot.outcome == 'success'
        run: |
          set -e  # Exit on any error

          TAG="${{ steps.snapshot.outputs.tag_name }}"
          echo "Calculating package size for: $TAG"

          # Sanitize TAG to prevent injection (allow only valid semver chars)
          TAG_SAFE=$(echo "$TAG" | sed 's/[^a-zA-Z0-9._-]//g')
          if [[ "$TAG" != "$TAG_SAFE" ]]; then
            echo "Error: TAG contains invalid characters"
            exit 1
          fi

          # Install dependencies and build the package
          echo "Installing dependencies..."
          pnpm install || { echo "Failed to install dependencies"; exit 1; }

          cd libs/engine
          echo "Building package..."
          pnpm run package || { echo "Failed to build package"; exit 1; }

          # Create tarball and measure its size
          echo "Creating tarball..."
          TARBALL=$(pnpm pack 2>/dev/null | tail -1)
          if [[ -z "$TARBALL" || ! -f "$TARBALL" ]]; then
            echo "Error: Failed to create tarball"
            exit 1
          fi

          # Get tarball size (cross-platform: try GNU stat, then BSD stat)
          TARBALL_SIZE=$(stat -c%s "$TARBALL" 2>/dev/null || stat -f%z "$TARBALL" 2>/dev/null)
          if [[ -z "$TARBALL_SIZE" ]]; then
            echo "Error: Failed to get tarball size"
            exit 1
          fi

          # Get unpacked size by extracting and measuring
          mkdir -p /tmp/pkg-measure
          tar -xzf "$TARBALL" -C /tmp/pkg-measure

          # Cross-platform size measurement (GNU du -sb, or BSD du -sk * 1024)
          if UNPACKED_SIZE=$(du -sb /tmp/pkg-measure/package 2>/dev/null | cut -f1); then
            :  # GNU du worked
          elif UNPACKED_SIZE_KB=$(du -sk /tmp/pkg-measure/package 2>/dev/null | cut -f1); then
            UNPACKED_SIZE=$((UNPACKED_SIZE_KB * 1024))
          else
            echo "Error: Failed to measure unpacked size"
            exit 1
          fi

          echo "Tarball: $TARBALL"
          echo "Compressed size: $TARBALL_SIZE bytes ($(numfmt --to=iec "$TARBALL_SIZE" 2>/dev/null || echo "$TARBALL_SIZE"))"
          echo "Unpacked size: $UNPACKED_SIZE bytes ($(numfmt --to=iec "$UNPACKED_SIZE" 2>/dev/null || echo "$UNPACKED_SIZE"))"

          # Update history.csv with the package size for this version
          # NOTE: This workflow calculates package size at tag time (pre-publish verification)
          # The backfill-npm-sizes.ts script fetches published versions (historical data recovery)
          cd ../..
          CSV_FILE="snapshots/history.csv"

          # Check if npm_unpacked_size column exists, add if not
          # IMPORTANT: New columns MUST be added at the end to maintain backward compatibility
          # with hardcoded column indexes in the CSV parsing code
          HEADER=$(head -1 "$CSV_FILE")
          if [[ "$HEADER" != *"npm_unpacked_size"* ]]; then
            echo "Adding npm_unpacked_size column to CSV..."
            # Add column header (MUST be added as the last column)
            sed -i "1s/$/,npm_unpacked_size/" "$CSV_FILE"
            # Add 0 to all existing rows
            sed -i "2,\$s/$/,0/" "$CSV_FILE"
          fi

          # Find the column index for npm_unpacked_size from header
          # This makes the script resilient to column additions before npm_unpacked_size
          SIZE_COL=$(head -1 "$CSV_FILE" | tr ',' '\n' | grep -n "npm_unpacked_size" | cut -d: -f1)
          if [[ -z "$SIZE_COL" ]]; then
            echo "Error: npm_unpacked_size column not found in CSV header"
            exit 1
          fi
          echo "Found npm_unpacked_size at column $SIZE_COL"

          # Update the size for this specific version using awk
          # Matches on column 2 (label/tag) and updates the size column by index
          awk -F, -v tag="$TAG" -v size="$UNPACKED_SIZE" -v col="$SIZE_COL" \
            'BEGIN {OFS=","} NR==1 {print; next} $2==tag {$col=size} {print}' \
            "$CSV_FILE" > "$CSV_FILE.tmp" && mv "$CSV_FILE.tmp" "$CSV_FILE"

          # Verify the update
          echo "Verifying update..."
          grep "$TAG" "$CSV_FILE" || { echo "Warning: Could not verify update"; }
          echo "Package size updated in $CSV_FILE"

          # Cleanup
          rm -f "$TARBALL"
          rm -rf /tmp/pkg-measure

      - name: Analyze documentation keywords
        if: steps.snapshot.outcome == 'success'
        run: |
          TAG="${{ steps.snapshot.outputs.tag_name }}"
          echo "Analyzing documentation keywords for: $TAG"

          # Run keyword analysis script
          pnpm exec tsx scripts/generate/analyze-doc-keywords.ts "$TAG" || echo "Warning: Keyword analysis failed, continuing..."

      - name: Sync data to landing page
        if: steps.snapshot.outcome == 'success'
        run: |
          # Ensure landing data directory exists
          mkdir -p apps/landing/static/data

          # Copy the history CSV so the /journey page can display it
          cp snapshots/history.csv apps/landing/static/data/history.csv

          # Copy release summaries so the /roadmap page can display them
          if [ -d snapshots/summaries ]; then
            mkdir -p apps/landing/static/data/summaries
            cp -r snapshots/summaries/* apps/landing/static/data/summaries/ 2>/dev/null || echo "No summaries to copy"
          fi

          # Copy word frequencies so the /journey page can display them
          if [ -d snapshots/word-frequencies ]; then
            mkdir -p apps/landing/static/data/word-frequencies
            cp -r snapshots/word-frequencies/* apps/landing/static/data/word-frequencies/ 2>/dev/null || echo "No word frequencies to copy"
          fi

      - name: Commit and push snapshot
        if: steps.snapshot.outcome == 'success'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add snapshot files, summaries, and landing data
          git add snapshots/ apps/landing/static/data/

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "docs: add repository snapshot and release summary for ${{ steps.snapshot.outputs.tag_name }}"
          git push origin main

      - name: Create GitHub Release
        if: steps.create_tag.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.create_tag.outputs.tag_name }}"
          VERSION="${{ steps.version.outputs.current }}"
          SUMMARY_FILE="snapshots/summaries/${TAG}.json"

          # Build release body from AI-generated summary
          if [ -f "$SUMMARY_FILE" ]; then
            SUMMARY=$(jq -r '.summary' "$SUMMARY_FILE")
            COMMITS=$(jq -r '.stats.totalCommits // "N/A"' "$SUMMARY_FILE")

            # Extract scopes (areas of work)
            SCOPES=$(jq -r '.scopes[]? // empty' "$SUMMARY_FILE" | head -8 | sed 's/^/`/;s/$/`/' | paste -sd ', ' -)

            # Build highlights sections â€” only include categories that have entries
            HIGHLIGHTS=""

            FEATURES=$(jq -r '.highlights.features[]? // empty' "$SUMMARY_FILE" | sed 's/^/- /')
            if [ -n "$FEATURES" ]; then
              HIGHLIGHTS="${HIGHLIGHTS}
          **Features**
          ${FEATURES}
          "
            fi

            FIXES=$(jq -r '.highlights.fixes[]? // empty' "$SUMMARY_FILE" | sed 's/^/- /')
            if [ -n "$FIXES" ]; then
              HIGHLIGHTS="${HIGHLIGHTS}
          **Fixes**
          ${FIXES}
          "
            fi

            REFACTORING=$(jq -r '.highlights.refactoring[]? // empty' "$SUMMARY_FILE" | sed 's/^/- /')
            if [ -n "$REFACTORING" ]; then
              HIGHLIGHTS="${HIGHLIGHTS}
          **Refactoring**
          ${REFACTORING}
          "
            fi

            PERF=$(jq -r '.highlights.performance[]? // empty' "$SUMMARY_FILE" | sed 's/^/- /')
            if [ -n "$PERF" ]; then
              HIGHLIGHTS="${HIGHLIGHTS}
          **Performance**
          ${PERF}
          "
            fi

            DOCS=$(jq -r '.highlights.docs[]? // empty' "$SUMMARY_FILE" | sed 's/^/- /')
            if [ -n "$DOCS" ]; then
              HIGHLIGHTS="${HIGHLIGHTS}
          **Docs**
          ${DOCS}
          "
            fi

            TESTS=$(jq -r '.highlights.tests[]? // empty' "$SUMMARY_FILE" | sed 's/^/- /')
            if [ -n "$TESTS" ]; then
              HIGHLIGHTS="${HIGHLIGHTS}
          **Tests**
          ${TESTS}
          "
            fi

            SCOPE_LINE=""
            if [ -n "$SCOPES" ]; then
              SCOPE_LINE="Areas: ${SCOPES} | "
            fi

            BODY="${SUMMARY}

          ### Highlights
          ${HIGHLIGHTS}
          ---
          ${SCOPE_LINE}*${COMMITS} total commits* | [npm](https://npm.pkg.github.com/package/@autumnsgrove/lattice) | [changelog](https://grove.autumn.pub/roadmap)"
          else
            BODY="## @autumnsgrove/lattice v${VERSION}

          See the [roadmap](https://grove.autumn.pub/roadmap) for details."
          fi

          gh release create "$TAG" \
            --title "@autumnsgrove/lattice ${TAG}" \
            --notes "$BODY"

          echo "Created GitHub Release: $TAG"

      - name: Publish to GitHub Package Registry
        if: steps.create_tag.outcome == 'success'
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure npm for GitHub Package Registry
          echo "@autumnsgrove:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${NODE_AUTH_TOKEN}" >> .npmrc

          cd libs/engine

          # Build the package (prepublishOnly runs svelte-package)
          pnpm run package

          # Publish
          pnpm publish --no-git-checks || echo "Warning: Publish failed (version may already exist)"

          echo "Published @autumnsgrove/lattice v${{ steps.version.outputs.current }}"

  # Separate job for backfilling historical summaries
  backfill:
    if: github.event.inputs.backfill_summaries == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Show versions to process
        run: |
          echo "ðŸ“‹ Versions in history.csv:"
          tail -n +2 snapshots/history.csv | cut -d',' -f2 | grep '^v' | sort -V
          echo ""
          echo "ðŸ“¦ Existing summaries:"
          ls -1 snapshots/summaries/ 2>/dev/null || echo "  (none)"

      - name: Run backfill script
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          chmod +x ./scripts/deploy/backfill-summaries.sh
          chmod +x ./scripts/generate/generate-release-summary.sh
          ./scripts/deploy/backfill-summaries.sh

      - name: Sync to landing page
        run: |
          mkdir -p apps/landing/static/data/summaries
          cp -r snapshots/summaries/* apps/landing/static/data/summaries/
          echo "ðŸ“¦ Synced summaries to apps/landing/static/data/summaries/"
          ls -1 apps/landing/static/data/summaries/

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add snapshots/summaries/ apps/landing/static/data/summaries/

          if git diff --staged --quiet; then
            echo "No new summaries generated"
            exit 0
          fi

          NEW_COUNT=$(git diff --staged --name-only | grep -c '\.json$' || echo "0")
          git commit -m "docs: backfill $NEW_COUNT historical release summaries"
          git push origin main
          echo "Pushed $NEW_COUNT new summaries to main"
